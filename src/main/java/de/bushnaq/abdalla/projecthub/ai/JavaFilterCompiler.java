/*
 *
 * Copyright (C) 2025-2025 Abdalla Bushnaq
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

package de.bushnaq.abdalla.projecthub.ai;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import javax.tools.*;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.lang.reflect.Method;
import java.net.URI;
import java.security.SecureClassLoader;
import java.time.LocalDate;
import java.util.*;
import java.util.function.Predicate;

/**
 * Service for compiling and executing Java filter code on the fly.
 * This service takes Java code generated by the LLM and compiles it at runtime,
 * then provides a Predicate that can be used to filter entities.
 */
@Service
public class JavaFilterCompiler {
    private static final String       CLASS_NAME_PREFIX = "GeneratedFilter";
    private static final String       PACKAGE_NAME      = "de.bushnaq.abdalla.projecthub.ai.generated";
    private static final Logger       logger            = LoggerFactory.getLogger(JavaFilterCompiler.class);
    private              int          classCounter      = 0;
    private final        JavaCompiler compiler;

    public JavaFilterCompiler() {
        this.compiler = ToolProvider.getSystemJavaCompiler();
        if (compiler == null) {
            throw new RuntimeException("Java compiler not available. Make sure you're running on a JDK, not JRE.");
        }
    }

    /**
     * Compiles and creates a Predicate from the given Java code.
     *
     * @param javaCode   The Java code for the filter method body
     * @param entityType The type of entity being filtered
     * @param now        The current date to use for date-based filtering (for testing purposes)
     * @param <T>        The entity type
     * @return A Predicate that can be used to filter entities
     * @throws RuntimeException if compilation or instantiation fails
     */
    public <T> Predicate<T> compileFilter(String javaCode, String entityType, LocalDate now) {
        try {
            String className     = CLASS_NAME_PREFIX + (++classCounter);
            String fullClassName = PACKAGE_NAME + "." + className;

            // Generate the complete Java class
            String completeJavaCode = generateCompleteJavaClass(className, javaCode, entityType);

            // Compile the Java code
            Class<?> compiledClass = compileJavaCode(fullClassName, completeJavaCode);

            // Create an instance of the compiled class
            Object instance = compiledClass.getDeclaredConstructor(LocalDate.class).newInstance(now);

            // Get the filter method
            Method filterMethod = compiledClass.getMethod("test", Object.class);

            // Return a Predicate that calls the compiled method
            return (T entity) -> {
                try {
                    return (Boolean) filterMethod.invoke(instance, entity);
                } catch (Exception e) {
                    logger.error("Error executing compiled filter: {}", e.getMessage(), e);
                    return false;
                }
            };

        } catch (Exception e) {
            logger.error("Failed to compile Java filter: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to compile Java filter: " + e.getMessage(), e);
        }
    }

    /**
     * Compiles and creates a Predicate from the given Java code using current date.
     *
     * @param javaCode   The Java code for the filter method body
     * @param entityType The type of entity being filtered
     * @param <T>        The entity type
     * @return A Predicate that can be used to filter entities
     * @throws RuntimeException if compilation or instantiation fails
     * @deprecated Use compileFilter(String, String, LocalDate) instead for better testability
     */
    @Deprecated
    public <T> Predicate<T> compileFilter(String javaCode, String entityType) {
        return compileFilter(javaCode, entityType, LocalDate.now());
    }

    /**
     * Compiles the Java source code and returns the compiled class.
     */
    private Class<?> compileJavaCode(String className, String sourceCode) throws Exception {
        // Create a file manager
        StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, null, null);

        // Create a custom class loader for loading the compiled class
        DynamicClassLoader classLoader = new DynamicClassLoader(this.getClass().getClassLoader());

        // Create a file object representing the source code
        JavaFileObject sourceFile = new InMemoryJavaFileObject(className, sourceCode);

        // Set up compilation options
        List<String> options = Arrays.asList("-cp", System.getProperty("java.class.path"), "-proc:none");

        // Create a custom file manager that stores compiled classes in memory
        InMemoryFileManager inMemoryFileManager = new InMemoryFileManager(fileManager, classLoader);

        // Create a diagnostic collector to capture compilation errors
        DiagnosticCollector<JavaFileObject> diagnosticCollector = new DiagnosticCollector<>();

        try {
            // Compile the source code
            JavaCompiler.CompilationTask task = compiler.getTask(
                    null, inMemoryFileManager, diagnosticCollector, options, null, List.of(sourceFile)
            );

            boolean success = task.call();

            if (!success) {
                // Throw custom exception with detailed compilation error information
                throw new JavaCompilationException(
                        "Java compilation failed",
                        sourceCode,
                        diagnosticCollector.getDiagnostics()
                );
            }

        } finally {
            // Ensure file manager is closed to trigger storing of compiled bytes
            inMemoryFileManager.close();
        }

        // Load and return the compiled class
        return classLoader.loadClass(className);
    }

    /**
     * Generates a complete Java class with the provided filter code.
     */
    private String generateCompleteJavaClass(String className, String filterCode, String entityType) {
        return String.format("""
                package %s;
                
                import java.util.function.Predicate;
                import java.time.*;
                import java.time.format.DateTimeFormatter;
                import java.util.*;
                import java.util.regex.Pattern;
                import de.bushnaq.abdalla.projecthub.dto.%s;
                import de.bushnaq.abdalla.projecthub.dto.Status;
                import de.bushnaq.abdalla.projecthub.dto.OffDayType;
                
                public class %s implements Predicate<%s> {
                
                    private final LocalDate now;
                
                    public %s(LocalDate now) {
                        this.now = now;
                    }
                
                    @Override
                    public boolean test(%s entity) {
                        if (entity == null) {
                            return false;
                        }
                
                        try {
                            // Execute the generated filter code
                            %s
                        } catch (Exception e) {
                            // Log the error but don't fail the entire filter
                            System.err.println("Error in filter execution: " + e.getMessage());
                            return false;
                        }
                    }
                
                    public LocalDate getNow() {
                        return now;
                    }
                
                }
                """, PACKAGE_NAME, entityType, className, entityType, className, entityType, filterCode);
    }

    /**
     * Generates a complete Java class with the provided filter code using current date.
     *
     * @deprecated Use generateCompleteJavaClass(String, String, String) instead
     */
    @Deprecated
    private String generateCompleteJavaClass(String className, String filterCode, String entityType, @SuppressWarnings("unused") LocalDate now) {
        return generateCompleteJavaClass(className, filterCode, entityType);
    }

    /**
     * Custom ClassLoader for loading dynamically compiled classes.
     */
    private static class DynamicClassLoader extends SecureClassLoader {
        private final Map<String, byte[]> classBytes = new HashMap<>();
        private final ClassLoader         parent;

        public DynamicClassLoader(ClassLoader parent) {
            super(parent);
            this.parent = parent;
//            logger.debug("DynamicClassLoader created");
        }

        public void addClassBytes(String name, byte[] classBytes) {
//            logger.debug("Adding class bytes for: {}, bytes length: {}", name, classBytes.length);
            this.classBytes.put(name, classBytes);
        }

        @Override
        protected Class<?> findClass(String name) throws ClassNotFoundException {
//            logger.debug("DynamicClassLoader.findClass called for: {}", name);
//            logger.debug("Available classes in classBytes: {}", classBytes.keySet());
//            logger.debug("classBytes map size: {}", classBytes.size());

            byte[] bytes = classBytes.get(name);
            if (bytes != null) {
//                logger.debug("Found class bytes for: {}, defining class", name);
                return defineClass(name, bytes, 0, bytes.length);
            }
            logger.debug("No class bytes found for: {}, delegating to parent", name);
            return super.findClass(name);
        }
    }

    /**
     * Custom file manager for handling in-memory compilation.
     */
    private static class InMemoryFileManager extends ForwardingJavaFileManager<StandardJavaFileManager> {
        private final DynamicClassLoader            classLoader;
        private final List<InMemoryJavaClassObject> classObjects = new ArrayList<>();

        public InMemoryFileManager(StandardJavaFileManager fileManager, DynamicClassLoader classLoader) {
            super(fileManager);
            this.classLoader = classLoader;
//            logger.debug("InMemoryFileManager created");
        }

        @Override
        public void close() throws IOException {
//            logger.debug("InMemoryFileManager.close() called, processing {} class objects", classObjects.size());
            // Ensure all compiled class bytes are stored before closing
            for (InMemoryJavaClassObject classObject : classObjects) {
                classObject.ensureClassBytesStored();
            }
            super.close();
        }

        @Override
        public JavaFileObject getJavaFileForOutput(Location location, String className, JavaFileObject.Kind kind, FileObject sibling) throws IOException {
//            logger.debug("getJavaFileForOutput called for: {}, kind: {}, location: {}", className, kind, location);
            if (kind == JavaFileObject.Kind.CLASS) {
//                logger.debug("Creating InMemoryJavaClassObject for: {}", className);
                InMemoryJavaClassObject classObject = new InMemoryJavaClassObject(className, classLoader);
                classObjects.add(classObject);
                return classObject;
            }
            return super.getJavaFileForOutput(location, className, kind, sibling);
        }
    }

    /**
     * In-memory representation of a compiled Java class.
     */
    private static class InMemoryJavaClassObject extends SimpleJavaFileObject {
        private final DynamicClassLoader    classLoader;
        private final String                className;
        private final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();

        public InMemoryJavaClassObject(String className, DynamicClassLoader classLoader) {
            super(URI.create("mem:///" + className.replace('.', '/') + Kind.CLASS.extension), Kind.CLASS);
            this.className   = className;
            this.classLoader = classLoader;
//            logger.debug("InMemoryJavaClassObject created for: {}", className);
        }

        @Override
        public boolean delete() {
//            logger.debug("delete() called for: {}, outputStream size: {}", className, outputStream.size());
            // Store the compiled class bytes in the class loader
            byte[] classBytes = outputStream.toByteArray();
//            logger.debug("Storing class bytes for: {}, bytes length: {}", className, classBytes.length);
            classLoader.addClassBytes(className, classBytes);
//            logger.debug("Successfully stored class bytes for: {}", className);
            return true;
        }

        public void ensureClassBytesStored() {
//            logger.debug("ensureClassBytesStored called for: {}, outputStream size: {}", className, outputStream.size());
            // Store the compiled class bytes in the class loader
            byte[] classBytes = outputStream.toByteArray();
//            logger.debug("Storing class bytes for: {}, bytes length: {}", className, classBytes.length);
            classLoader.addClassBytes(className, classBytes);
//            logger.debug("Successfully stored class bytes for: {}", className);
        }

        @Override
        public OutputStream openOutputStream() throws IOException {
//            logger.debug("openOutputStream called for: {}", className);
            return outputStream;
        }
    }

    /**
     * In-memory representation of a Java source file.
     */
    private static class InMemoryJavaFileObject extends SimpleJavaFileObject {
        private final String sourceCode;

        public InMemoryJavaFileObject(String className, String sourceCode) {
            super(URI.create("string:///" + className.replace('.', '/') + Kind.SOURCE.extension), Kind.SOURCE);
            this.sourceCode = sourceCode;
        }

        @Override
        public CharSequence getCharContent(boolean ignoreEncodingErrors) {
            return sourceCode;
        }
    }
}
